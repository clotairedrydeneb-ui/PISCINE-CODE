#include <stdio.h>  
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_LABELS 256
#define MAX_LINE   256

typedef struct {
    char name[64];
    int address;
} Label;

Label labels[MAX_LABELS];
int label_count = 0;

int PC = 0;   // program counter
void trim(char* s)
{
    char* p = s;
    while (isspace(*p)) p++;
    memmove(s, p, strlen(p) + 1);

    int len = strlen(s);
    while (len > 0 && isspace(s[len - 1])) {
        s[len - 1] = '\0';
        len--;
    }
}

int is_empty_or_comment(const char* s)
{
    return s[0] == '\0' || s[0] == ';';
}

void add_label(const char* name, int address)
{
    for (int i = 0; i < label_count; i++) {
        if (strcmp(labels[i].name, name) == 0) {
            printf("Erreur: label dupliqué %s\n", name);
            return;
        }
    }

    strcpy(labels[label_count].name, name);
    labels[label_count].address = address;
    label_count++;
}
int parse_db(const char* args)
{
    int count = 0;
    char tmp[MAX_LINE];
    strcpy(tmp, args);

    char* token = strtok(tmp, ",");
    while (token) {
        trim(token);

        if (token[0] == '\'' && token[2] == '\'') {
            // caractère genre 'A'
            count += 1;
        }
        else {
            // nombre
            count += 1;
        }

        token = strtok(NULL, ",");
    }
    return count;
}
void parse_line_pass1(char* line)
{
    trim(line);

    if (is_empty_or_comment(line))
        return;

    // Label ?
    char* colon = strchr(line, ':');
    if (colon) {
        *colon = '\0';
        trim(line);
        add_label(line, PC);
        line = colon + 1;
        trim(line);

        if (*line == '\0')
            return;
    }

    // Récupérer le mnemonic
    char mnemonic[32] = { 0 };
    char args[MAX_LINE] = { 0 };

    sscanf(line, "%31s %[^\n]", mnemonic, args);

    // ORG
    if (strcasecmp(mnemonic, "ORG") == 0) {
        int value = 0;
        if (args[0] == '0' && args[1] == 'x')
            value = strtol(args, NULL, 16);
        else
            value = atoi(args);

        PC = value;
        return;
    }

    // DB
    if (strcasecmp(mnemonic, "DB") == 0) {
        int size = parse_db(args);
        PC += size;
        return;
    }

    // Instruction inconnue (on suppose 1 octet pour l’instant)
    PC += 1;
}
void pass1(FILE* f)
{
    char line[MAX_LINE];
    PC = 0;

    while (fgets(line, sizeof(line), f)) {
        // enlever commentaire
        char* comment = strchr(line, ';');
        if (comment)
            *comment = '\0';

        parse_line_pass1(line);
    }
}
// Ajout de la fonction strcasecmp si elle n'est pas disponible
int strcasecmp(const char* s1, const char* s2)
{
    while (*s1 && *s2) {
        char c1 = tolower((unsigned char)*s1);
        char c2 = tolower((unsigned char)*s2);
        if (c1 != c2)
            return c1 - c2;
        s1++;
        s2++;
    }
    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

int main(int argc, char** argv)
{
    if (argc < 2) {
        printf("Usage: assembler fichier.asm\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if (!f) {
        perror("fopen");
        return 1;
    }

    pass1(f);
    fclose(f);

    printf("Labels trouvés:\n");
    for (int i = 0; i < label_count; i++) {
        printf("%s = 0x%04X\n", labels[i].name, labels[i].address);
    }

    return 0;
}    
